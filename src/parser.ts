import { ASTNode, Token, TokenType } from "./types";

/**
 * Parses a list of tokens into an Abstract Syntax Tree (AST) representing the structure of the mathematical expression.
 *
 * @param tokens - An array of tokens generated by the tokenizer.
 * @returns The root of the AST representing the parsed mathematical expression.
 *
 * Steps:
 * 1. Start with `parseExpression()` to handle the lowest precedence operations.
 * 2. Break expressions into terms (`parseTerm()`) for higher precedence operations (* and /).
 * 3. Further split terms into factors (`parseFactor()`) to handle numbers and grouped expressions.
 */
export function parse(tokens: Token[]): ASTNode {
  let position = 0;

  /**
   * Parses expressions with the lowest precedence (e.g., "+" and "-").
   *
   * @returns An AST node representing a binary operation or a single term.
   */
  function parseExpression(): ASTNode {
    let left = parseTerm();

    while (
      position < tokens.length &&
      ["+", "-"].includes(tokens[position].value)
    ) {
      const operator = tokens[position].value;
      position++;
      const right = parseTerm();
      left = { type: "BinaryOperation", operator, left, right };
    }

    return left;
  }

  /**
   * Parses terms with medium precedence (e.g., "*" and "/").
   *
   * @returns An AST node representing a binary operation or a single factor.
   */
  function parseTerm(): ASTNode {
    let left = parseFactor();

    while (
      position < tokens.length &&
      ["*", "/"].includes(tokens[position].value)
    ) {
      const operator = tokens[position].value;
      position++;
      const right = parseFactor();
      left = { type: "BinaryOperation", operator, left, right };
    }

    return left;
  }

  /**
   * Parses the highest precedence elements: numbers and grouped expressions.
   *
   * @returns An AST node representing a literal value or a grouped expression.
   * @throws If the token is neither a number nor a left parenthesis.
   */
  function parseFactor(): ASTNode {
    const token = tokens[position];
    position++;

    if (token.type === TokenType.NUMBER) {
      return { type: "Literal", value: parseFloat(token.value) };
    } else if (token.type === TokenType.LEFT_PARENTHESIS) {
      const expression = parseExpression();
      position++;
      return expression;
    } else {
      throw new Error(`Unexpected token: ${token.value}`);
    }
  }

  return parseExpression();
}
